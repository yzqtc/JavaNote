<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>接口</title>
	</head>
	<script type="text/javascript" src="../js/index/import.js"></script>
	<body>
		<!--
        	作者：1548185173@qq.com
        	时间：2020-03-27
        	描述：接口
        -->
        <center>
			<h1>接口</h1>  
        </center>
		<div>
			<ul>
				<li id="1" class="fontsize thick">接口的作用</li>					
			</ul>
			<ul class="ul">
				<li class="fontsize null_string">
					一个类只能继承一个父类，但是可以继承N个接口。
				</li>					
			</ul>
			<ul class="ul">
				<li class="fontsize null_string">
					接口的目的是指明相关或者不相关类的多个对象的共同行为，跟抽象类很相似，可以说接口是更加抽象的抽象类。
				</li>					
			</ul>
			<ul class="ul">
				<li class="fontsize null_string">
					接口体现了程序设计的多态和高内聚低耦合的设计思想。
				</li>					
			</ul>
			<ul>
				<li id="2" class="fontsize thick">定义接口和使用接口</li>					
			</ul>
			<ul class="ul">
				<li class="fontsize null_string">
					声明格式:
				</li>					
			</ul>
			<div class="margin_left80 code_border position_relative">
				<div class="fontsize number_border">
					<div class="code_number_border">1</div>
					<div class="code_number_border">2</div>
					<div class="code_number_border">3</div>
					<div class="code_number_border">4</div>
				</div>
				<div class="fontsize" id="codediv_1">
					<div>[访问修饰符] interface 接口名   [extends 父接口1，父接口2…]  {</div>
					<div class="right_1">常量定义</div>
					<div class="right_1">方法定义</div>
					<div>}</div>
				</div>
				<div class="copy" id="copy_1" style="cursor: pointer;" data-clipboard-action="copy" data-clipboard-target="#codediv_1">复制</div>
			</div>
			<ul class="ul">
				<li class="fontsize null_string thick">
					定义接口的详细说明:
				</li>					
			</ul>
			<ul class="ul">
				<li class="fontsize string_1">
					1.访问修饰符：只能是public或默认。
				</li>					
			</ul>
			<ul class="ul">
				<li class="fontsize string_1">
					2.接口名：和类名采用相同命名机制。
				</li>					
			</ul>
			<ul class="ul">
				<li class="fontsize string_1">
					3.extends：接口可以多继承。
				</li>					
			</ul>
			<ul class="ul">
				<li class="fontsize string_1">
					4.常量：接口中的属性只能是常量，总是：public static final 修饰。不写也是。
				</li>					
			</ul>
			<ul class="ul">
				<li class="fontsize string_1">
					5.方法：接口中的方法只能是：public abstract。 省略的话，也是public abstract。
				</li>					
			</ul>
			<ul class="ul">
				<li class="fontsize null_string thick">
					要点:
				</li>					
			</ul>
			<ul class="ul">
				<li class="fontsize string_1">
					1.子类通过implements来实现接口中的规范。
				</li>					
			</ul>
			<ul class="ul">
				<li class="fontsize string_1">
					2.接口不能创建实例，但是可用于声明引用变量类型。
				</li>					
			</ul>
			<ul class="ul">
				<li class="fontsize string_1">
					3.接口中不能有构造方法。
				</li>					
			</ul>
			<ul class="ul">
				<li class="fontsize string_1">
					4.一个类实现了接口，必须实现接口中所有的方法，并且这些方法只能是public的。
				</li>					
			</ul>
			<ul class="ul">
				<li class="fontsize string_1">
					5.JDK1.7之前，接口中只能包含静态常量、抽象方法，不能有普通属性、构造方法、普通方法。
				</li>					
			</ul>
			<ul class="ul">
				<li class="fontsize string_1">
					6.JDK1.8后，接口中包含普通的静态方法。
				</li>					
			</ul>
			<ul class="ul">
				<li class="fontsize null_string">
					[示例]接口的使用:
				</li>					
			</ul>
			<div class="margin_left80 code_border position_relative">
				<div class="fontsize number_border">
					<div class="code_number_border">1</div>
					<div class="code_number_border">2</div>
					<div class="code_number_border">3</div>
					<div class="code_number_border">4</div>
					<div class="code_number_border">5</div>
					<div class="code_number_border">6</div>
					<div class="code_number_border">7</div>
					<div class="code_number_border">8</div>
					<div class="code_number_border">9</div>
					<div class="code_number_border">10</div>
					<div class="code_number_border">11</div>
					<div class="code_number_border">12</div>
					<div class="code_number_border">13</div>
					<div class="code_number_border">14</div>
					<div class="code_number_border">15</div>
					<div class="code_number_border">16</div>
					<div class="code_number_border">17</div>
					<div class="code_number_border">18</div>
					<div class="code_number_border">19</div>
					<div class="code_number_border">20</div>
					<div class="code_number_border">21</div>
					<div class="code_number_border">22</div>
					<div class="code_number_border">23</div>
					<div class="code_number_border">24</div>
					<div class="code_number_border">25</div>
					<div class="code_number_border">26</div>
					<div class="code_number_border">27</div>
					<div class="code_number_border">28</div>
					<div class="code_number_border">29</div>
					<div class="code_number_border">30</div>
					<div class="code_number_border">31</div>
					<div class="code_number_border">32</div>
					<div class="code_number_border">33</div>
					<div class="code_number_border">34</div>
					<div class="code_number_border">35</div>
					<div class="code_number_border">36</div>
					<div class="code_number_border">37</div>
				</div>
				<div class="fontsize" id="codediv_2">
					<div>public class TestInterface {</div>
					<div class="right_1">public static void main(String[] args) {</div>
					<div class="right_2">Volant volant = new Angel();</div>
					<div class="right_2">volant.fly();</div>
					<div class="right_2">System.out.println(Volant.FLY_HIGHT);</div>
					<div class="right_2">Honest honest = new GoodMan();</div>
					<div class="right_2">honest.helpOther();</div>
					<div class="right_1">}</div>
					<div>}</div>
					<div>/**飞行接口*/</div>
					<div>interface Volant {</div>
					<div class="right_1">int FLY_HIGHT = 100; // 总是：public static final类型的</div>
					<div class="right_1">void fly(); //总是：public abstract void fly()</div>
					<div>}</div>
					<div>/**善良接口*/</div>
					<div>interface Honest { </div>
					<div class="right_1">void helpOther();</div>
					<div>}</div>
					<div>/**Angle类实现飞行接口和善良接口*/</div>
					<div>class Angel implements Volant, Honest{</div>
					<div class="right_1">public void fly() {</div>
					<div class="right_2">System.out.println("我是天使，飞起来啦！");</div>
					<div class="right_1">}</div>
					<div class="right_1">public void helpOther() {</div>
					<div class="right_2">System.out.println("扶老奶奶过马路！");</div>
					<div class="right_1">}</div>
					<div>}</div>
					<div>class GoodMan implements Honest {</div>
					<div class="right_1">public void helpOther() {</div>
					<div class="right_2">System.out.println("扶老奶奶过马路！");</div>
					<div class="right_1">}</div>
					<div>}</div>
					<div>class BirdMan implements Volant {</div>
					<div class="right_1">public void fly() {</div>
					<div class="right_2">System.out.println("我是鸟人，正在飞！");</div>
					<div class="right_1">}</div>
					<div>}</div>
				</div>
				<div class="copy" id="copy_2" style="cursor: pointer;" data-clipboard-action="copy" data-clipboard-target="#codediv_2">复制</div>
			</div>
			<ul class="ul">
				<li class="fontsize null_string">
					<img src="../img/2.29_1.png" />
				</li>					
			</ul>
			<ul>
				<li id="3" class="fontsize thick">接口的多继承</li>					
			</ul>
			<ul class="ul">
				<li class="fontsize null_string">
					接口完全支持多继承。和类的继承类似，子接口扩展某个父接口，将会获得父接口中所定义的一切。
				</li>					
			</ul>
			<ul class="ul">
				<li class="fontsize null_string">
					[示例]接口的多继承:
				</li>					
			</ul>
			<div class="margin_left80 code_border position_relative">
				<div class="fontsize number_border">
					<div class="code_number_border">1</div>
					<div class="code_number_border">2</div>
					<div class="code_number_border">3</div>
					<div class="code_number_border">4</div>
					<div class="code_number_border">5</div>
					<div class="code_number_border">6</div>
					<div class="code_number_border">7</div>
					<div class="code_number_border">8</div>
					<div class="code_number_border">9</div>
					<div class="code_number_border">10</div>
					<div class="code_number_border">11</div>
					<div class="code_number_border">12</div>
					<div class="code_number_border">13</div>
					<div class="code_number_border">14</div>
					<div class="code_number_border">15</div>
					<div class="code_number_border">16</div>
					<div class="code_number_border">17</div>
					<div class="code_number_border">18</div>
				</div>
				<div class="fontsize" id="codediv_3">
					<div>interface A {</div>
					<div class="right_1">void testa();</div>
					<div>}</div>
					<div>interface B {</div>
					<div class="right_1">void testb();</div>
					<div>}</div>
					<div>/**接口可以多继承：接口C继承接口A和B*/</div>
					<div>interface C extends A, B {</div>
					<div class="right_1">void testc();</div>
					<div>}</div>
					<div>public class Test implements C {</div>
					<div class="right_1">public void testc() {</div>
					<div class="right_1">}</div>
					<div class="right_1">public void testa() {</div>
					<div class="right_1">}</div>
					<div class="right_1">public void testb() {</div>
					<div class="right_1">}</div>
					<div>}</div>
				</div>
				<div class="copy" id="copy_3" style="cursor: pointer;" data-clipboard-action="copy" data-clipboard-target="#codediv_3">复制</div>
			</div>
			<ul>
				<li id="4" class="fontsize thick">面向接口编程</li>					
			</ul>
			<ul class="ul">
				<li class="fontsize null_string">
					面向接口编程是面向对象编程的一部分。
				</li>					
			</ul>
			<ul class="ul">
				<li class="fontsize null_string">
					使用面向接口编程主要有3点好处:
				</li>					
			</ul>
			<ul class="ul">
				<li class="fontsize string_1">
					代码的灵活性和高可复用性
				</li>					
			</ul>
			<ul class="ul">
				<li class="fontsize string_1">
					良好的可扩展性
				</li>					
			</ul>
			<ul class="ul">
				<li class="fontsize string_1">
					低耦合
				</li>					
			</ul>
			<ul>
				<li id="5" class="fontsize thick">抽象类和接口的区别</li>					
			</ul>
			<ul class="ul">
				<li class="fontsize">
					<table class="margin_left40" border="1px solid" bordercolor="#d0d0d0" cellpadding="0" cellspacing="0" width="800px" height="150px">
						<tr align="center">
							<td>参数</td>
							<td>抽象类</td>
							<td>接口</td>
						</tr>
						<tr align="left">
							<td width="100px">默认的方法实现</td>
							<td>它可以有默认的方法实现</td>
							<td>接口完全是抽象的。它根本不存在方法的实现</td>
						</tr>
						<tr align="left">
							<td>实现</td>
							<td>子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现</td>
							<td>子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现</td>
						</tr>
						<tr align="left">
							<td>构造器</td>
							<td>抽象类可以有构造器</td>
							<td>接口不能有构造器</td>
						</tr>
						<tr align="left">
							<td>访问修饰符</td>
							<td>抽象方法可以有public、protected和default这些修饰符</td>
							<td>接口方法默认修饰符是public不可以使用其它修饰符</td>
						</tr>
						<tr align="left">
							<td>main方法</td>
							<td>抽象方法可以有main方法并且我们可以运行它</td>
							<td>接口没有main方法，因此我们不能运行它。（java8以后接口可以有default和static方法，所以可以运行main方法）</td>
						</tr>
						<tr align="left">
							<td>main方法</td>
							<td>抽象方法可以有main方法并且我们可以运行它</td>
							<td>接口没有main方法，因此我们不能运行它。（java8以后接口可以有default和static方法，所以可以运行main方法）</td>
						</tr>
						<tr align="left">
							<td>多继承</td>
							<td>抽象方法可以继承一个类和实现多个接口</td>
							<td>接口可以继承一个或多个其它接口</td>
						</tr>
						<tr align="left">
							<td>速度</td>
							<td>它比接口速度要快</td>
							<td>接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法</td>
						</tr>
						<tr align="left">
							<td>添加新方法</td>
							<td>如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码</td>
							<td>如果你往接口中添加方法，那么你必须改变实现该接口的类</td>
						</tr>
					</table>
				</li>					
			</ul>
			<ul class="ul">
				<li class="fontsize null_string thick">
					什么时候使用抽象类和接口
				</li>					
			</ul>
			<ul class="ul">
				<li class="fontsize string_1">
					如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类。
				</li>					
			</ul>
			<ul class="ul">
				<li class="fontsize string_1">
					如果你想实现多重继承，那么你必须使用接口。由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。
				</li>					
			</ul>
			<ul class="ul">
				<li class="fontsize string_1">
					如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。
				</li>					
			</ul>
		</div>
	</body>
</html>
